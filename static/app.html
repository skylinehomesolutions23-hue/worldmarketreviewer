<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>WorldMarketReviewer</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; margin: 0; padding: 16px; background: #ffffff; color: #111827; }
    h1 { font-size: 20px; margin: 0 0 8px 0; }
    .card { border: 1px solid #eee; border-radius: 12px; padding: 12px; margin: 12px 0; }
    input, select { width: 100%; padding: 12px; font-size: 16px; border: 1px solid #ddd; border-radius: 10px; box-sizing: border-box; }
    button { width: 100%; padding: 12px; font-size: 16px; border: 0; border-radius: 10px; background: #111827; color: white; font-weight: 800; }
    button:disabled { opacity: 0.6; }
    .row { display: flex; justify-content: space-between; gap: 8px; align-items: center; flex-wrap: wrap; }
    .row > * { flex: 1; }
    .muted { opacity: 0.75; }
    .item { padding: 10px 0; border-bottom: 1px solid #f0f0f0; }
    .item:last-child { border-bottom: 0; }
    .pill { display: inline-block; padding: 4px 10px; border-radius: 999px; font-size: 12px; background: #f3f4f6; }
    .pill-up { background: #dcfce7; color: #14532d; }
    .pill-down { background: #fee2e2; color: #7f1d1d; }
    .pill-uncertain { background: #e0e7ff; color: #1e3a8a; }
    .small { font-size: 12px; }
    .toggle {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px;
      border-radius: 10px;
      border: 1px solid #e5e7eb;
      background: #f9fafb;
      user-select: none;
    }
    .toggle input { width: 18px; height: 18px; }
    .hr { height: 1px; background: #f1f5f9; margin: 12px 0; }

    .chips { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 10px; }
    .chip {
      border: 1px solid #e5e7eb;
      background: #ffffff;
      border-radius: 999px;
      padding: 8px 12px;
      font-size: 13px;
      cursor: pointer;
      user-select: none;
      font-weight: 800;
    }
    .chip:active { transform: scale(0.98); }
    .chip.selected {
      border-color: #111827;
      background: #111827;
      color: #ffffff;
    }

    .chipRow { display: flex; gap: 8px; margin-top: 10px; flex-wrap: wrap; }
    .miniBtn {
      width: auto;
      padding: 8px 10px;
      font-size: 12px;
      border-radius: 10px;
      background: #1f2937;
      color: #fff;
      border: 0;
      font-weight: 800;
    }
    .miniBtn.secondary {
      background: #f3f4f6;
      color: #111827;
      border: 1px solid #e5e7eb;
    }

    .bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .selectedLine {
      margin-top: 10px;
      padding: 10px;
      border: 1px dashed #e5e7eb;
      border-radius: 10px;
      background: #fcfcfd;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      overflow-wrap: anywhere;
    }
  </style>
</head>
<body>
  <h1>WorldMarketReviewer</h1>
  <div class="muted">Tap tickers to select. Pick a horizon. Run.</div>

  <div class="card">
    <div class="row">
      <div>
        <div class="muted small" style="margin-bottom:6px;">Horizon</div>
        <select id="horizon">
          <option value="1">1 day</option>
          <option value="5" selected>5 days</option>
          <option value="10">10 days</option>
          <option value="21">21 days</option>
        </select>
      </div>
      <div>
        <div class="muted small" style="margin-bottom:6px;">Max parallel</div>
        <select id="maxParallel">
          <option value="1">1 (safest)</option>
          <option value="2">2</option>
          <option value="3" selected>3</option>
          <option value="4">4</option>
        </select>
      </div>
    </div>

    <div class="hr"></div>

    <div class="toggle" style="margin-bottom:10px;">
      <input id="retrain" type="checkbox" checked />
      <div>
        <div><b>Retrain every run</b></div>
        <div class="muted small">Turn OFF to reuse cached models (faster + more stable).</div>
      </div>
    </div>

    <button id="runBtn" disabled>Run Predictions</button>

    <div id="meta" class="muted small" style="margin-top:10px;"></div>
    <div id="status" class="muted" style="margin-top:6px;"></div>
  </div>

  <div class="card">
    <div class="bar">
      <div>
        <b>Choose tickers to run</b>
        <div class="muted small">Selections persist on this phone.</div>
      </div>
      <div>
        <span id="selectedCount" class="pill"></span>
      </div>
    </div>

    <div class="chipRow">
      <button class="miniBtn secondary" id="selectAllBtn" type="button">Select all</button>
      <button class="miniBtn secondary" id="clearBtn" type="button">Clear</button>
      <button class="miniBtn" id="defaultsBtn" type="button">Defaults</button>
    </div>

    <div class="selectedLine" id="selectedLine">Selected: (none)</div>

    <div class="hr"></div>

    <div class="muted small" style="margin-bottom:6px;">Search tickers</div>
    <input id="search" placeholder="Type e.g. XL or NVDA" />

    <div class="chips" id="tickerGrid"></div>
    <div class="muted small" id="filterNote" style="margin-top:10px;"></div>
  </div>

  <div class="card">
    <div class="row">
      <div><b>Results</b></div>
      <div id="runPill" class="pill" style="display:none;"></div>
    </div>
    <div id="results" class="muted" style="margin-top:10px;">No results yet.</div>
  </div>

<script>
  const API = ""; // same origin

  const AVAILABLE_TICKERS = [
    "AMZN","META","TSLA","NVDA","NFLX","AMD","INTC","JPM","BAC","GS",
    "MS","XOM","CVX","SPY","QQQ","DIA","ORCL","IBM","CRM","ADBE","WMT",
    "COST","HD","PFE","JNJ","UNH","BA","CAT","GE","XLK","XLF","XLE",
    "XLV","XLI","XLY","XLP","XLU"
  ];

  const DEFAULT_SELECTED = ["SPY","QQQ","NVDA"];

  const STORAGE = {
    selected: "wmr:web:selectedTickers:v3",
    retrain: "wmr:web:retrain:v3",
    horizon: "wmr:web:horizon:v3",
    maxParallel: "wmr:web:maxParallel:v3"
  };

  const UNCERTAIN_BAND = 0.02;

  const elRunBtn = document.getElementById("runBtn");
  const elStatus = document.getElementById("status");
  const elMeta = document.getElementById("meta");
  const elResults = document.getElementById("results");
  const elRunPill = document.getElementById("runPill");
  const elRetrain = document.getElementById("retrain");
  const elHorizon = document.getElementById("horizon");
  const elMaxParallel = document.getElementById("maxParallel");

  const elGrid = document.getElementById("tickerGrid");
  const elSelectedCount = document.getElementById("selectedCount");
  const elSelectedLine = document.getElementById("selectedLine");

  const elSelectAllBtn = document.getElementById("selectAllBtn");
  const elClearBtn = document.getElementById("clearBtn");
  const elDefaultsBtn = document.getElementById("defaultsBtn");

  const elSearch = document.getElementById("search");
  const elFilterNote = document.getElementById("filterNote");

  let selected = new Set();
  let filter = "";

  function save(key, val) { try { localStorage.setItem(key, JSON.stringify(val)); } catch {} }
  function load(key, fallback) {
    try { const v = localStorage.getItem(key); return v ? JSON.parse(v) : fallback; }
    catch { return fallback; }
  }

  function uniqUpper(list) {
    return (list || []).map(x => String(x).toUpperCase().trim())
      .filter(Boolean).filter((t, i, a) => a.indexOf(t) === i);
  }

  function fmtPct(x) { return (typeof x === "number") ? (x * 100).toFixed(1) + "%" : "-"; }
  function clamp01(x) { return (typeof x === "number") ? Math.max(0, Math.min(1, x)) : null; }

  function pillForProb(probUp) {
    const p = clamp01(probUp);
    if (p === null) return { label: "UNKNOWN", cls: "pill-uncertain" };
    if (Math.abs(p - 0.5) <= UNCERTAIN_BAND) return { label: "UNCERTAIN", cls: "pill-uncertain" };
    return p >= 0.5 ? { label: "UP", cls: "pill-up" } : { label: "DOWN", cls: "pill-down" };
  }

  function setStatus(text) { elStatus.textContent = text || ""; }
  function setMeta(text) { elMeta.textContent = text || ""; }

  function updateSelectedUI() {
    const list = Array.from(selected);
    elSelectedCount.textContent = `Selected: ${list.length}`;
    elSelectedLine.textContent = list.length ? `Selected: ${list.join(",")}` : "Selected: (none)";
    elRunBtn.disabled = list.length === 0;
    save(STORAGE.selected, list);
  }

  function getFilteredTickers() {
    const list = uniqUpper(AVAILABLE_TICKERS);
    const f = (filter || "").trim().toUpperCase();
    if (!f) return list;
    return list.filter(t => t.includes(f));
  }

  function renderGrid() {
    const list = getFilteredTickers();
    const all = uniqUpper(AVAILABLE_TICKERS);

    elGrid.innerHTML = list.map(t => {
      const cls = selected.has(t) ? "chip selected" : "chip";
      return `<div class="${cls}" data-t="${t}">${t}</div>`;
    }).join("");

    elFilterNote.textContent = (list.length === all.length)
      ? `${all.length} tickers`
      : `Showing ${list.length} of ${all.length} (filter: "${(filter || "").trim()}")`;

    elGrid.querySelectorAll("[data-t]").forEach(node => {
      node.addEventListener("click", () => {
        const t = node.getAttribute("data-t");
        if (!t) return;
        if (selected.has(t)) selected.delete(t); else selected.add(t);
        updateSelectedUI();
        renderGrid();
      });
    });
  }

  function setResults(preds) {
    if (!preds || preds.length === 0) { elResults.textContent = "No results."; return; }
    elResults.innerHTML = preds.map(p => {
      const pill = pillForProb(p.prob_up);
      const exp = (typeof p.exp_return === "number") ? p.exp_return : 0;
      const hz = (typeof p.horizon_days === "number") ? p.horizon_days : parseInt(elHorizon.value || "5", 10);
      return `
        <div class="item">
          <div class="row">
            <div><b>${p.ticker ?? "-"}</b> <span class="pill ${pill.cls}">${pill.label}</span></div>
            <div>${fmtPct(p.prob_up)}</div>
          </div>
          <div class="muted small">Expected: ${exp.toFixed(4)} | Horizon: ${hz}d</div>
        </div>
      `;
    }).join("");
  }

  async function startRun(tickers) {
    const retrain = !!elRetrain.checked;
    const horizon_days = parseInt(elHorizon.value || "5", 10);
    const max_parallel = parseInt(elMaxParallel.value || "3", 10);

    const res = await fetch(`${API}/api/run_phase2`, {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify({ tickers, max_parallel, retrain, horizon_days })
    });
    return res.json();
  }

  async function getStatus(runId) {
    const res = await fetch(`${API}/api/run_phase2/status?run_id=${encodeURIComponent(runId)}`);
    return res.json();
  }

  async function getSummary(runId) {
    const res = await fetch(`${API}/api/summary?run_id=${encodeURIComponent(runId)}`);
    return res.json();
  }

  elSelectAllBtn.addEventListener("click", () => {
    uniqUpper(AVAILABLE_TICKERS).forEach(t => selected.add(t));
    updateSelectedUI(); renderGrid();
  });

  elClearBtn.addEventListener("click", () => {
    selected = new Set();
    updateSelectedUI(); renderGrid();
  });

  elDefaultsBtn.addEventListener("click", () => {
    selected = new Set(uniqUpper(DEFAULT_SELECTED));
    updateSelectedUI(); renderGrid();
  });

  elRetrain.addEventListener("change", () => save(STORAGE.retrain, !!elRetrain.checked));
  elHorizon.addEventListener("change", () => save(STORAGE.horizon, elHorizon.value));
  elMaxParallel.addEventListener("change", () => save(STORAGE.maxParallel, elMaxParallel.value));

  elSearch.addEventListener("input", () => {
    filter = elSearch.value || "";
    renderGrid();
  });

  elRunBtn.addEventListener("click", async () => {
    const tickers = Array.from(selected);
    if (tickers.length === 0) return;

    elRunBtn.disabled = true;
    setMeta(""); setStatus("Starting run..."); setResults([]);

    const started = await startRun(tickers);
    if (started.error) {
      setStatus("Error: " + started.error);
      elRunBtn.disabled = false;
      updateSelectedUI();
      return;
    }

    const runId = started.run_id;
    elRunPill.style.display = "inline-block";
    elRunPill.textContent = runId;

    setMeta(`retrain=${elRetrain.checked ? "1" : "0"} • horizon=${elHorizon.value}d • parallel=${elMaxParallel.value} • tickers=${tickers.join(",")}`);
    setStatus(`Running... 0/${started.total ?? tickers.length}`);

    const poll = setInterval(async () => {
      const s = await getStatus(runId);
      if (s.error) {
        setStatus("Error: " + s.error);
        clearInterval(poll);
        elRunBtn.disabled = false;
        updateSelectedUI();
        return;
      }
      setStatus(`Status: ${s.status} — ${s.progress.completed}/${s.progress.total}`);

      if (s.status === "finished") {
        clearInterval(poll);
        const out = await getSummary(runId);
        setResults(out.predictions || []);
        setStatus("Finished.");
        elRunBtn.disabled = false;
        updateSelectedUI();
      }
    }, 1500);
  });

  (function init() {
    const savedSel = load(STORAGE.selected, []);
    selected = new Set(uniqUpper(Array.isArray(savedSel) ? savedSel : []));

    const savedRetrain = load(STORAGE.retrain, null);
    if (typeof savedRetrain === "boolean") elRetrain.checked = savedRetrain;

    const savedH = load(STORAGE.horizon, null);
    if (savedH !== null) elHorizon.value = String(savedH);

    const savedMP = load(STORAGE.maxParallel, null);
    if (savedMP !== null) elMaxParallel.value = String(savedMP);

    if (selected.size === 0) DEFAULT_SELECTED.forEach(t => selected.add(String(t).toUpperCase().trim()));

    updateSelectedUI();
    renderGrid();
  })();
</script>
</body>
</html>
